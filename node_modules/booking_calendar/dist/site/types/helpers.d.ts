import { EventType, QronoEventType, SlotsType } from "./interfaces";
/**
   * This function converts arrays of bookings, bookable events, open periods and closed periods into one single array
   * of events with the eventType property
   * @param {EventType} bookings An array of booking events
   * @param {EventType} bookableEvents An array of bookable events
   * @param {EventType} openPeriods An array of open period events
   * @param {EventType} closedPeriods An array of closed period events
   * @return {QronoEventType} Returns an array of events with the corresponfing type
*/
export declare const convertToQronoEvents: (bookings?: EventType[] | undefined, bookableEvents?: EventType[] | undefined, openPeriods?: EventType[] | undefined, closedPeriods?: EventType[] | undefined) => QronoEventType[];
export interface CategorizedEvents {
    closedPeriods: EventType[];
    openPeriods: EventType[];
    bookableEvents: EventType[];
    bookings: EventType[];
}
/**
   * This function converts an array of events (each event specifying the type) into an object where each prop is an array
   * of events classified by the type
   *
   * @param {QronoEventType} events An array of events
   * @return {CategorizedEvents} Returns an object with the events classified by type
*/
export declare const categorizeEvents: (events: QronoEventType[]) => CategorizedEvents;
/**
   * This function verifies if a DateTime falls within a given event. In other words: is the given Date between the start and end of the given Event.
   * @param {QronoEventType} event An object with the start, end, id and availability of a event
   * @param {Date} selectedDay the specific DateTime to test
   * @param {string} timezone the timezone of the calendar
   * @return {boolean} Returns true if the specified day is within the event, otherwise returns false. Note that this does not work for events which are shorter than a day.
*/
export declare const isDayWithinEvent: (event: EventType, selectedDate: Date, timezone: string) => boolean;
/**
   * This class is intended to handle the time for the Scrolling Timepicker
   * @param {number} time This is an optional number to instantiate the class
   * @param {Date} date This is an optional date to instantiate the class
   * @function format Returns the time as a string with the format passed indicated in the argument or ther format h:mm A
   * @function toString Returns the time in the format hh:mm am/pm as a string
   * @function toMilitaryTime Returns the time in a military format as a number
   * @function hours Returns the hours as a number
   * @function minutes Returns the minutes as a number
*/
export declare class Time {
    private value;
    constructor(time: number | Date | string, timezone?: string);
    private format;
    toString(timezone?: string): string;
    toMilitaryTime(): number;
    hours(): number;
    minutes(): number;
}
/**
   * This function will use two arrays of events and returns all the periods of the first array that do not overlap
   * the events of the precedentEvents array
   *
   * @param {EventType[]} events An array of events
   * @param {EventType[]} precedentEvents An array of events that take precedence over the events from the other array
   * @returns {EventType[]} An array of events
*/
export declare const spliceEvents: (events: EventType[], precedentEvents: EventType[]) => EventType[];
/**
   * This function will use one array of events, join all the elements that overlap into one element, and return an array with
   * these joined events
   *
   * @param {EventType[]} events The array of events
   * @returns {EventType[]} An array with events that do not overlap at all
*/
export declare const joinEvents: (events: EventType[]) => EventType[];
/**
   * This function will use one array of events and range of dates , and returns an array with all events between the
   * events given considering only the range specified
   *
   * Another way to think about it, an event will be created from every empty period between event within the range specified
   *
   * @param {EventType[]} events The array of sorted events
   * @param {EventType} range An event with the range used to calculate the new aray of events
   * @returns {EventType[]} An array with events
*/
export declare const getEmptyPeriods: (events: EventType[], range: EventType) => EventType[];
/**
   * This function indicates if two events are overlaping somehow
   *
   * @param {EventType} eventOne The first event to assess
   * @param {EventType} eventTwo The second event to assess
   * @returns {boolean} True if the events overlaps otherwise it returns false
*/
export declare const overlappingEvents: (eventOne: EventType, eventTwo: EventType) => boolean;
/**
   * This function calculates all the blocking periods given an array of bookings
   *
   * @param {EventType[]} bookings An array with all of the bookings for the date that will be assessed
   * @param {string} timezone The timezone for the calendar
   * @param {number} capacity The capacity of the calendar to be booked simultaneously
   * @returns {EventType[]} The blocking periods for the specific date according to the given bookings
*/
export declare const getBlockingPeriodsByBookings: (capacity: number, bookings?: EventType[]) => EventType[];
/**
   * This function will use the openPeriods, closedPeriods, bookableEvents and bookings provided in an array of
   * events and return all periods of availability, taking into consideration capacity for bookings.
   *
   * If defaultAvailable is equal to false, closedPeriods, bookings and bookableEvents take precedence over openPeriods.
   * If defaultAvailable is equal to true, the function getBlockingPeriods will be used to calculate the available periods
   *
   * Another way to think of this is that getBlockingPeriods gets all the availability specified EXPLICITLY by the
   * events provided.
   *
   * All events will be converted to UTC if timezone is specified, otherwise they will be assumed to be UTC.
   * The blockingPeriods will all be returned in UTC time.
   *
   * @param {EventType} blockingPeriodsByBookings An array of the periods blocked by the bookings exceding the capacity
   * @param {EventType} bookableEvents An array of bookable events
   * @param {EventType} openPeriods An array of open period events
   * @param {EventType} closedPeriods An array of closed period events
   * @param {boolean} defaultAvailable Indicates if the day should be available or unavailable by default
   * @returns {EventType[]} All the available periods given the events specified
 */
export declare const getAvailablePeriods: (blockingPeriodsByBookings: EventType[], categorizedEvents: CategorizedEvents, defaultAvailable: boolean) => EventType[];
/**
   * This function will use the openPeriods, closedPeriods, bookableEvents and bookings provided in an array of
   * events and return all periods blocked or disabled to be selected, taking into consideration capacity for bookings.
   *
   * If defaultAvailable is equal to false, closedPeriods, bookings and bookableEvents take precedence over openPeriods.
   * If defaultAvailable is equal to true, openPeriods will override closedPeriods, for the purpose of allowing
   * exceptions to scheduled closure. However, bookings and bookableEvents will still override those openPeriods,
   * since the item can't be double booked.
   *
   * Another way to think of this is that getBlockingPeriods gets all the unavailability specified EXPLICITLY by the
   * events provided.
   *
   * All events will be converted to UTC if timezone is specified, otherwise they will be assumed to be UTC.
   * The blockingPeriods will all be returned in UTC time.
   *
   * @param {QronoEventType[]} events An array with all of the events of the calendar
   * @param {number} capacity Indicates the maximum capacity that has the calendar to be booked simultaneously
   * @param {boolean} defaultAvailable Indicates if the day should be available or unavailable by default
   * @param {EventType} range Indicates the range of dates to calculate the blockingPeriods
   * @param {EventType} blockingPeriodsByBookings An array of the periods blocked by the bookings exceding the capacity
   * @param {EventType[]} prevBlockingPeriods Indicates the blocking periods that were calculated previously
   * @param {EventType[]} prevAvailablePeriods IIndicates the available periods that were calculated previously
   * @returns {EventType[]} All the blocking periods given the events specified
 */
export declare const getBlockingPeriods: (categorizedEvents: CategorizedEvents, defaultAvailable: boolean, range: EventType, blockingPeriodsByBookings?: EventType[], prevBlockingPeriods?: EventType[] | undefined, prevAvailablePeriods?: EventType[]) => EventType[];
/**
   * This function calculates all the enabled slots given the available periods and the interval of the slots
   *
   * @param {EventType[]} blockingPeriods An array with all the blocking periods for the selected date
   * @param {number | "quarterHour" | "halfHour" | "hour" | "day" | "night"} interval The size of the interval that is used to calculate the slots
   * @param {string} timezone The timezone for the calendar
   * @param {Date} selectedDay The specific DateTime to test
   * @returns {SlotsType[]} An array with the slots that are enabled to be booked
*/
export declare const getEnabledSlots: (interval: number | "quarterHour" | "halfHour" | "hour" | "day" | "night", timezone: string, blockingPeriods: EventType[], selectedDay?: Date | undefined) => SlotsType[];
/**
   * This function verifies if the day displayed in the calendar is disabled according to the events and the config
   * @param {EventType[]} blockingPeriods An array with all of the unavailable events
   * @param {Date} date The specific DateTime to test
   * @param {string} timezone Indicates the timezone for the calendar
   * @return {boolean} Returns true if the day is disabled or false if it is enabled.
*/
export declare const isDayDisabled: (date: Date, timezone: string, blockingPeriods: EventType[]) => boolean;
export declare const convertDayIntoEvent: (date?: Date | undefined, timezone?: string | undefined) => {
    start: Date;
    end: Date;
};
